"use strict";
// Copyright 2018-2024 the oak authors. All rights reserved. MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSentEventStreamTarget = exports.ServerSentEvent = void 0;
const tslib_1 = require("tslib");
/**
 * Provides {@linkcode ServerSentEvent} and
 * {@linkcode ServerSentEventStreamTarget} which provides an interface to send
 * server sent events to a browser using the DOM event model.
 *
 * The {@linkcode ServerSentEventStreamTarget} provides the `.asResponse()` or
 * `.asResponseInit()` to provide a body and headers to the client to establish
 * the event connection. This is accomplished by keeping a connection open to
 * the client by not closing the body, which allows events to be sent down the
 * connection and processed by the client browser.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ## Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/unstable_server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   let counter = 0;
 *
 *   // Sends an event every 2 seconds, incrementing the ID
 *   const id = setInterval(() => {
 *     const evt = new ServerSentEvent(
 *       "message",
 *       { data: { hello: "world" }, id: counter++ },
 *     );
 *     target.dispatchEvent(evt);
 *   }, 2000);
 *
 *   target.addEventListener("close", () => clearInterval(id));
 *   return target.asResponse();
 * });
 * ```
 *
 * @module
 */
const dntShim = tslib_1.__importStar(require("../../../../_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const encoder = new TextEncoder();
const DEFAULT_KEEP_ALIVE_INTERVAL = 30000;
class CloseEvent extends Event {
    constructor(eventInit) {
        super("close", eventInit);
    }
}
/**
 * An event which contains information which will be sent to the remote
 * connection and be made available in an `EventSource` as an event. A server
 * creates new events and dispatches them on the target which will then be
 * sent to a client.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ### Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   const evt = new ServerSentEvent("message", {
 *     data: { hello: "world" },
 *     id: 1
 *   });
 *   target.dispatchEvent(evt);
 *   return target.asResponse();
 * });
 * ```
 */
class ServerSentEvent extends Event {
    #data;
    #id;
    #type;
    /**
     * @param type the event type that will be available on the client. The type
     *             of `"message"` will be handled specifically as a message
     *             server-side event.
     * @param eventInit initialization options for the event
     */
    constructor(type, eventInit = {}) {
        super(type, eventInit);
        const { data, replacer, space } = eventInit;
        this.#type = type;
        try {
            this.#data = typeof data === "string"
                ? data
                : data !== undefined
                    ? JSON.stringify(data, replacer, space)
                    : "";
        }
        catch (e) {
            (0, deps_js_1.assert)(e instanceof Error);
            throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
        }
        const { id } = eventInit;
        this.#id = id;
    }
    /** The data associated with the event, which will be sent to the client and
     * be made available in the `EventSource`. */
    get data() {
        return this.#data;
    }
    /** The optional ID associated with the event that will be sent to the client
     * and be made available in the `EventSource`. */
    get id() {
        return this.#id;
    }
    toString() {
        const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
        return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
    }
}
exports.ServerSentEvent = ServerSentEvent;
const RESPONSE_HEADERS = [
    ["Connection", "Keep-Alive"],
    ["Content-Type", "text/event-stream"],
    ["Cache-Control", "no-cache"],
    ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
];
/**
 * An implementation of {@linkcode ServerSentEventTarget} that provides a
 * readable stream as a body of a response to establish a connection to a
 * client.
 */
class ServerSentEventStreamTarget extends EventTarget {
    #bodyInit;
    #closed = false;
    #controller;
    // we are ignoring any here, because when exporting to npm/Node.js, the timer
    // handle isn't a number.
    // deno-lint-ignore no-explicit-any
    #keepAliveId;
    // deno-lint-ignore no-explicit-any
    #error(error) {
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        const errorEvent = new ErrorEvent("error", { error });
        this.dispatchEvent(errorEvent);
    }
    #push(payload) {
        if (!this.#controller) {
            this.#error(new Error("The controller has not been set."));
            return;
        }
        if (this.#closed) {
            return;
        }
        this.#controller.enqueue(encoder.encode(payload));
    }
    get closed() {
        return this.#closed;
    }
    constructor({ keepAlive = false } = {}) {
        super();
        this.#bodyInit = new ReadableStream({
            start: (controller) => {
                this.#controller = controller;
            },
            cancel: (error) => {
                // connections closing are considered "normal" for SSE events and just
                // mean the far side has closed.
                if (error instanceof Error && error.message.includes("connection closed")) {
                    this.close();
                }
                else {
                    this.#error(error);
                }
            },
        });
        this.addEventListener("close", () => {
            this.#closed = true;
            if (this.#keepAliveId !== null && this.#keepAliveId !== undefined) {
                clearInterval(this.#keepAliveId);
                this.#keepAliveId = undefined;
            }
            if (this.#controller) {
                try {
                    this.#controller.close();
                }
                catch {
                    // we ignore any errors here, as it is likely that the controller
                    // is already closed
                }
            }
        });
        if (keepAlive) {
            const interval = typeof keepAlive === "number"
                ? keepAlive
                : DEFAULT_KEEP_ALIVE_INTERVAL;
            this.#keepAliveId = setInterval(() => {
                this.dispatchComment("keep-alive comment");
            }, interval);
        }
    }
    /** Returns a {@linkcode Response} which contains the body and headers needed
     * to initiate a SSE connection with the client. */
    asResponse(responseInit) {
        return new dntShim.Response(...this.asResponseInit(responseInit));
    }
    /** Returns a tuple which contains the {@linkcode BodyInit} and
     * {@linkcode ResponseInit} needed to create a response that will establish
     * a SSE connection with the client. */
    asResponseInit(responseInit = {}) {
        const headers = new dntShim.Headers(responseInit.headers);
        for (const [key, value] of RESPONSE_HEADERS) {
            headers.set(key, value);
        }
        responseInit.headers = headers;
        return [this.#bodyInit, responseInit];
    }
    close() {
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        return Promise.resolve();
    }
    dispatchComment(comment) {
        this.#push(`: ${comment.split("\n").join("\n: ")}\n\n`);
        return true;
    }
    // deno-lint-ignore no-explicit-any
    dispatchMessage(data) {
        const event = new ServerSentEvent("__message", { data });
        return this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const dispatched = super.dispatchEvent(event);
        if (dispatched && event instanceof ServerSentEvent) {
            this.#push(String(event));
        }
        return dispatched;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({ "#bodyInit": this.#bodyInit, "#closed": this.#closed })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#bodyInit": this.#bodyInit, "#closed": this.#closed }, newOptions)}`;
    }
}
exports.ServerSentEventStreamTarget = ServerSentEventStreamTarget;
