// Copyright 2018-2024 the oak authors. All rights reserved. MIT license.
/** The abstraction that oak uses when dealing with requests and responses
 * within the Node.js runtime.
 *
 * @module
 */
import * as dntShim from "./_dnt.shims.js";
import { createPromiseWithResolvers } from "./util.js";
export class NodeRequest {
    #request;
    #response;
    #responded = false;
    get remoteAddr() {
        const addr = this.#request.socket.address();
        // deno-lint-ignore no-explicit-any
        return addr && addr?.address;
    }
    get headers() {
        return new dntShim.Headers(this.#request.headers);
    }
    get method() {
        return this.#request.method ?? "GET";
    }
    get url() {
        return this.#request.url ?? "";
    }
    constructor(request, response) {
        this.#request = request;
        this.#response = response;
    }
    // deno-lint-ignore no-explicit-any
    error(reason) {
        if (this.#responded) {
            throw new Error("Request already responded to.");
        }
        let error;
        if (reason) {
            error = reason instanceof Error ? reason : new Error(String(reason));
        }
        this.#response.destroy(error);
        this.#responded = true;
    }
    getBody() {
        let body;
        if (this.method === "GET" || this.method === "HEAD") {
            body = null;
        }
        else {
            body = new ReadableStream({
                start: (controller) => {
                    this.#request.on("data", (chunk) => {
                        controller.enqueue(chunk);
                    });
                    this.#request.on("error", (err) => {
                        controller.error(err);
                    });
                    this.#request.on("end", () => {
                        controller.close();
                    });
                },
            });
        }
        return body;
    }
    async respond(response) {
        if (this.#responded) {
            throw new Error("Requested already responded to.");
        }
        for (const [key, value] of response.headers) {
            this.#response.setHeader(key, value);
        }
        this.#response.writeHead(response.status, response.statusText);
        if (response.body) {
            for await (const chunk of response.body) {
                const { promise, resolve, reject } = createPromiseWithResolvers();
                // deno-lint-ignore no-explicit-any
                this.#response.write(chunk, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
                await promise;
            }
        }
        const { promise, resolve } = createPromiseWithResolvers();
        this.#response.end(resolve);
        await promise;
        this.#responded = true;
    }
}
export class Server {
    #abortController = new AbortController();
    #host;
    #port;
    #requestStream;
    constructor(_app, options) {
        this.#host = options.hostname ?? "127.0.0.1";
        this.#port = options.port;
    }
    close() {
        this.#abortController.abort();
    }
    async listen() {
        const { createServer } = await import("http");
        let server;
        this.#requestStream = new ReadableStream({
            start(controller) {
                server = createServer((req, res) => {
                    // deno-lint-ignore no-explicit-any
                    controller.enqueue(new NodeRequest(req, res));
                });
            },
        });
        server.listen({
            port: this.#port,
            host: this.#host,
            signal: this.#abortController.signal,
        });
        return {
            addr: {
                port: this.#port,
                hostname: this.#host,
            },
        };
    }
    [Symbol.asyncIterator]() {
        if (!this.#requestStream) {
            throw new TypeError("stream not properly initialized");
        }
        return this.#requestStream[Symbol.asyncIterator]();
    }
    static type = "node";
}
