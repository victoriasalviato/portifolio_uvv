// Copyright 2018-2024 the oak authors. All rights reserved. MIT license.
/**
 * Contains the core concept of oak, the middleware application. Typical usage
 * is the creation of an application instance, registration of middleware, and
 * then starting to listen for requests.
 *
 * # Example
 *
 * ```ts
 * import { Application } from "jsr:@oak/oak@14/application";
 *
 * const app = new Application();
 * app.use((ctx) => {
 *   ctx.response.body = "hello world!";
 * });
 *
 * app.listen({ port: 8080 });
 * ```
 *
 * @module
 */
import * as dntShim from "./_dnt.shims.js";
import { Context } from "./context.js";
import { assert, KeyStack, STATUS_TEXT } from "./deps.js";
import { compose, isMiddlewareObject, } from "./middleware.js";
import { cloneState } from "./structured_clone.js";
import { createPromiseWithResolvers, isBun, isNetAddr, isNode, } from "./util.js";
const ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
let DefaultServerCtor;
let NativeRequestCtor;
/** An event that occurs when the application closes. */
export class ApplicationCloseEvent extends Event {
    constructor(eventInitDict) {
        super("close", eventInitDict);
    }
}
/** An event that occurs when an application error occurs.
 *
 * When the error occurs related to the handling of a request, the `.context`
 * property will be populated.
 */
export class ApplicationErrorEvent extends ErrorEvent {
    context;
    constructor(eventInitDict) {
        super("error", eventInitDict);
        this.context = eventInitDict.context;
    }
}
function logErrorListener({ error, context }) {
    if (error instanceof Error) {
        console.error(`[uncaught application error]: ${error.name} - ${error.message}`);
    }
    else {
        console.error(`[uncaught application error]\n`, error);
    }
    if (context) {
        let url;
        try {
            url = context.request.url.toString();
        }
        catch {
            url = "[malformed url]";
        }
        console.error(`\nrequest:`, {
            url,
            method: context.request.method,
            hasBody: context.request.hasBody,
        });
        console.error(`response:`, {
            status: context.response.status,
            type: context.response.type,
            hasBody: !!context.response.body,
            writable: context.response.writable,
        });
    }
    if (error instanceof Error && error.stack) {
        console.error(`\n${error.stack.split("\n").slice(1).join("\n")}`);
    }
}
/**
 * An event that occurs when the application starts listening for requests.
 */
export class ApplicationListenEvent extends Event {
    hostname;
    listener;
    port;
    secure;
    serverType;
    constructor(eventInitDict) {
        super("listen", eventInitDict);
        this.hostname = eventInitDict.hostname;
        this.listener = eventInitDict.listener;
        this.port = eventInitDict.port;
        this.secure = eventInitDict.secure;
        this.serverType = eventInitDict.serverType;
    }
}
/** A class which registers middleware (via `.use()`) and then processes
 * inbound requests against that middleware (via `.listen()`).
 *
 * The `context.state` can be typed via passing a generic argument when
 * constructing an instance of `Application`. It can also be inferred by setting
 * the {@linkcode ApplicationOptions.state} option when constructing the
 * application.
 *
 * ### Basic example
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx, next) => {
 *   // called on each request with the context (`ctx`) of the request,
 *   // response, and other data.
 *   // `next()` is use to modify the flow control of the middleware stack.
 * });
 *
 * app.listen({ port: 8080 });
 * ```
 *
 * @template AS the type of the application state which extends
 *              {@linkcode State} and defaults to a simple string record.
 */
// deno-lint-ignore no-explicit-any
export class Application extends EventTarget {
    #composedMiddleware;
    #contextOptions;
    #contextState;
    #keys;
    #middleware = [];
    #serverConstructor;
    /** A set of keys, or an instance of `KeyStack` which will be used to sign
     * cookies read and set by the application to avoid tampering with the
     * cookies. */
    get keys() {
        return this.#keys;
    }
    set keys(keys) {
        if (!keys) {
            this.#keys = undefined;
            return;
        }
        else if (Array.isArray(keys)) {
            this.#keys = new KeyStack(keys);
        }
        else {
            this.#keys = keys;
        }
    }
    /** If `true`, proxy headers will be trusted when processing requests.  This
     * defaults to `false`. */
    proxy;
    /** Generic state of the application, which can be specified by passing the
     * generic argument when constructing:
     *
     *       const app = new Application<{ foo: string }>();
     *
     * Or can be contextually inferred based on setting an initial state object:
     *
     *       const app = new Application({ state: { foo: "bar" } });
     *
     * When a new context is created, the application's state is cloned and the
     * state is unique to that request/response.  Changes can be made to the
     * application state that will be shared with all contexts.
     */
    state;
    constructor(options = {}) {
        super();
        const { state, keys, proxy, serverConstructor, contextState = "clone", logErrors = true, ...contextOptions } = options;
        this.proxy = proxy ?? false;
        this.keys = keys;
        this.state = state ?? {};
        this.#serverConstructor = serverConstructor;
        this.#contextOptions = contextOptions;
        this.#contextState = contextState;
        if (logErrors) {
            this.addEventListener("error", logErrorListener);
        }
    }
    #getComposed() {
        if (!this.#composedMiddleware) {
            this.#composedMiddleware = compose(this.#middleware);
        }
        return this.#composedMiddleware;
    }
    #getContextState() {
        switch (this.#contextState) {
            case "alias":
                return this.state;
            case "clone":
                return cloneState(this.state);
            case "empty":
                return {};
            case "prototype":
                return Object.create(this.state);
        }
    }
    /** Deal with uncaught errors in either the middleware or sending the
     * response. */
    // deno-lint-ignore no-explicit-any
    #handleError(context, error) {
        if (!(error instanceof Error)) {
            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
        }
        const { message } = error;
        if (!context.response.writable) {
            this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
            return;
        }
        for (const key of [...context.response.headers.keys()]) {
            context.response.headers.delete(key);
        }
        if (error.headers && error.headers instanceof dntShim.Headers) {
            for (const [key, value] of error.headers) {
                context.response.headers.set(key, value);
            }
        }
        context.response.type = "text";
        const status = context.response.status =
            dntShim.dntGlobalThis.Deno && dntShim.Deno.errors && error instanceof dntShim.Deno.errors.NotFound
                ? 404
                : error.status && typeof error.status === "number"
                    ? error.status
                    : 500;
        context.response.body = error.expose ? error.message : STATUS_TEXT[status];
        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
    }
    /** Processing registered middleware on each request. */
    async #handleRequest(request, secure, state) {
        let context;
        try {
            context = new Context(this, request, this.#getContextState(), { secure, ...this.#contextOptions });
        }
        catch (e) {
            const error = e instanceof Error
                ? e
                : new Error(`non-error thrown: ${JSON.stringify(e)}`);
            const { message } = error;
            this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
            return;
        }
        assert(context, "Context was not created.");
        const { promise, resolve } = createPromiseWithResolvers();
        state.handling.add(promise);
        if (!state.closing && !state.closed) {
            try {
                await this.#getComposed()(context);
            }
            catch (err) {
                this.#handleError(context, err);
            }
        }
        if (context.respond === false) {
            context.response.destroy();
            resolve();
            state.handling.delete(promise);
            return;
        }
        let closeResources = true;
        let response;
        try {
            closeResources = false;
            response = await context.response.toDomResponse();
        }
        catch (err) {
            this.#handleError(context, err);
            response = await context.response.toDomResponse();
        }
        assert(response);
        try {
            await request.respond(response);
        }
        catch (err) {
            this.#handleError(context, err);
        }
        finally {
            context.response.destroy(closeResources);
            resolve();
            state.handling.delete(promise);
            if (state.closing) {
                await state.server.close();
                if (!state.closed) {
                    this.dispatchEvent(new ApplicationCloseEvent({}));
                }
                state.closed = true;
            }
        }
    }
    /** Add an event listener for an event.  Currently valid event types are
     * `"error"` and `"listen"`. */
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
    }
    /** A method that is compatible with the Cloudflare Worker
     * [Fetch Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/)
     * and can be exported to handle Cloudflare Worker fetch requests.
     *
     * # Example
     *
     * ```ts
     * import { Application } from "@oak/oak";
     *
     * const app = new Application();
     * app.use((ctx) => {
     *   ctx.response.body = "hello world!";
     * });
     *
     * export default { fetch: app.fetch };
     * ```
     */
    fetch = async (request, _env, _ctx) => {
        if (!this.#middleware.length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        if (!NativeRequestCtor) {
            const { NativeRequest } = await import("./http_server_native_request.js");
            NativeRequestCtor = NativeRequest;
        }
        let remoteAddr;
        const hostname = request.headers.get("CF-Connecting-IP") ?? undefined;
        if (hostname) {
            remoteAddr = { hostname, port: 0, transport: "tcp" };
        }
        const contextRequest = new NativeRequestCtor(request, { remoteAddr });
        const context = new Context(this, contextRequest, this.#getContextState(), this.#contextOptions);
        try {
            await this.#getComposed()(context);
            const response = await context.response.toDomResponse();
            context.response.destroy(false);
            return response;
        }
        catch (err) {
            this.#handleError(context, err);
            throw err;
        }
    };
    /** Handle an individual server request, returning the server response.  This
     * is similar to `.listen()`, but opening the connection and retrieving
     * requests are not the responsibility of the application.  If the generated
     * context gets set to not to respond, then the method resolves with
     * `undefined`, otherwise it resolves with a request that is compatible with
     * `std/http/server`. */
    handle = (async (request, secureOrAddr, secure = false) => {
        if (!this.#middleware.length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        assert(isNetAddr(secureOrAddr) || typeof secureOrAddr === "undefined");
        if (!NativeRequestCtor) {
            const { NativeRequest } = await import("./http_server_native_request.js");
            NativeRequestCtor = NativeRequest;
        }
        const contextRequest = new NativeRequestCtor(request, {
            remoteAddr: secureOrAddr,
        });
        const context = new Context(this, contextRequest, this.#getContextState(), { secure, ...this.#contextOptions });
        try {
            await this.#getComposed()(context);
        }
        catch (err) {
            this.#handleError(context, err);
        }
        if (context.respond === false) {
            context.response.destroy();
            return;
        }
        try {
            const response = await context.response.toDomResponse();
            context.response.destroy(false);
            return response;
        }
        catch (err) {
            this.#handleError(context, err);
            throw err;
        }
    });
    async listen(options = { port: 0 }) {
        if (!this.#middleware.length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        for (const middleware of this.#middleware) {
            if (isMiddlewareObject(middleware) && middleware.init) {
                await middleware.init();
            }
        }
        if (typeof options === "string") {
            const match = ADDR_REGEXP.exec(options);
            if (!match) {
                throw TypeError(`Invalid address passed: "${options}"`);
            }
            const [, hostname, portStr] = match;
            options = { hostname, port: parseInt(portStr, 10) };
        }
        options = Object.assign({ port: 0 }, options);
        if (!this.#serverConstructor) {
            if (!DefaultServerCtor) {
                const { Server } = await (isBun()
                    ? import("./http_server_bun.js")
                    : isNode()
                        ? import("./http_server_node.js")
                        : import("./http_server_native.js"));
                DefaultServerCtor = Server;
            }
            this.#serverConstructor = DefaultServerCtor;
        }
        const server = new this.#serverConstructor(this, options);
        const state = {
            closed: false,
            closing: false,
            handling: new Set(),
            server,
        };
        const { signal } = options;
        if (signal) {
            signal.addEventListener("abort", () => {
                if (!state.handling.size) {
                    state.closed = true;
                    this.dispatchEvent(new ApplicationCloseEvent({}));
                }
                state.closing = true;
            }, { once: true });
        }
        const { secure = false } = options;
        const serverType = this.#serverConstructor.type ?? "custom";
        const listener = await server.listen();
        const { hostname, port } = listener.addr;
        this.dispatchEvent(new ApplicationListenEvent({
            hostname,
            listener,
            port,
            secure,
            serverType,
        }));
        try {
            for await (const request of server) {
                this.#handleRequest(request, secure, state);
            }
            await Promise.all(state.handling);
        }
        catch (error) {
            const message = error instanceof Error
                ? error.message
                : "Application Error";
            this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
        }
    }
    use(...middleware) {
        this.#middleware.push(...middleware);
        this.#composedMiddleware = undefined;
        // deno-lint-ignore no-explicit-any
        return this;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { keys, proxy, state } = this;
        return `${this.constructor.name} ${inspect({ "#middleware": this.#middleware, keys, proxy, state })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { keys, proxy, state } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#middleware": this.#middleware, keys, proxy, state }, newOptions)}`;
    }
}
