/** Middleware that converts the oak specific context to a Fetch API standard
 * {@linkcode Request} and {@linkcode Response} along with a modified context
 * providing some of the oak functionality. This is intended to make it easier
 * to adapt code to work with oak.
 *
 * There are two functions which will "wrap" a handler that operates off a
 * Fetch API request and response and return an oak middleware. The
 * {@linkcode serve} is designed for using with the {@linkcode Application}
 * `.use()` method, while {@linkcode route} is designed for using with the
 * {@linkcode Router}.
 *
 * > [!IMPORTANT]
 * > This is not intended for advanced use cases that are supported by oak,
 * > like integrated cookie management, web sockets and server sent events.
 * >
 * > Also, these are designed to be very deterministic request/response handlers
 * > versus a more nuanced middleware stack which allows advanced control.
 * > Therefore there is no `next()`.
 * >
 * > For these advanced use cases, create middleware without the wrapper.
 *
 * @module
 */
import * as dntShim from "../_dnt.shims.js";
import { type Application, type State } from "../application.js";
import { Context } from "../context.js";
import { type ErrorStatus, type HttpErrorOptions } from "../deps.js";
import { type Middleware } from "../middleware.js";
import { type Layer, type RouteParams, type Router, type RouterContext, type RouterMiddleware } from "../router.js";
/** The context associated when dealing with serve middleware requests on an
 * application. */
export declare class ServeContext<S extends State = State> {
    #private;
    /** A reference to the current application. */
    get app(): Application<S>;
    /** Request remote address. When the application's `.proxy` is true, the
     * `X-Forwarded-For` will be used to determine the requesting remote address.
     */
    get ip(): string;
    /** When the application's `.proxy` is `true`, this will be set to an array of
     * IPs, ordered from upstream to downstream, based on the value of the header
     * `X-Forwarded-For`.  When `false` an empty array is returned. */
    get ips(): string[];
    /** The object to pass state to front-end views.  This can be typed by
     * supplying the generic state argument when creating a new app.  For
     * example:
     *
     * ```ts
     * const app = new Application<{ foo: string }>();
     * ```
     *
     * Or can be contextually inferred based on setting an initial state object:
     *
     * ```ts
     * const app = new Application({ state: { foo: "bar" } });
     * ```
     *
     * On each request/response cycle, the context's state is cloned from the
     * application state. This means changes to the context's `.state` will be
     * dropped when the request drops, but "defaults" can be applied to the
     * application's state.  Changes to the application's state though won't be
     * reflected until the next request in the context's state.
     */
    get state(): S;
    constructor(context: Context<S>);
    /** Asserts the condition and if the condition fails, creates an HTTP error
     * with the provided status (which defaults to `500`).  The error status by
     * default will be set on the `.response.status`.
     *
     * Because of limitation of TypeScript, any assertion type function requires
     * specific type annotations, so the {@linkcode ServeContext} type should be
     * used even if it can be inferred from the context.
     */
    assert(condition: unknown, status?: ErrorStatus, message?: string, props?: Record<string, unknown> & Omit<HttpErrorOptions, "status">): asserts condition;
    /** Create and throw an HTTP Error, which can be used to pass status
     * information which can be caught by other middleware to send more
     * meaningful error messages back to the client.  The passed error status will
     * be set on the `.response.status` by default as well.
     */
    throw(errorStatus: ErrorStatus, message?: string, props?: Record<string, unknown>): never;
}
/** The context associated with serve middleware requests on a router. */
export declare class RouteContext<R extends string, P extends RouteParams<R> = RouteParams<R>, S extends State = State> extends ServeContext<S> {
    #private;
    /** When matching the route, an array of the capturing groups from the regular
     * expression. */
    get captures(): string[];
    /** The routes that were matched for this request. */
    get matched(): Layer<R, P, S>[] | undefined;
    /** Any parameters parsed from the route when matched. */
    get params(): P;
    /** A reference to the router instance. */
    get router(): Router<S>;
    /** If the matched route has a `name`, the matched route name is provided
     * here. */
    get routeName(): string | undefined;
    /** Overrides the matched path for future route middleware, when a
     * `routerPath` option is not defined on the `Router` options. */
    get routerPath(): string | undefined;
    constructor(context: RouterContext<R, P, S>);
}
type ServeMiddleware<S extends State> = (request: dntShim.Request, context: ServeContext<S>) => dntShim.Response | Promise<dntShim.Response>;
type ServeRouterMiddleware<R extends string, P extends RouteParams<R>, S extends State> = (request: dntShim.Request, context: RouteContext<R, P, S>) => dntShim.Response | Promise<dntShim.Response>;
/** Wrap a handler function to generate middleware that can be used with an oak
 * {@linkcode Application}. This allows the handler to deal with a Fetch API
 * standard {@linkcode Request} and return a standard {@linkcode Response}.
 */
export declare function serve<S extends State>(middleware: ServeMiddleware<S>): Middleware<S>;
/** Wrap a handler function to generate middleware that can be used with an oak
 * {@linkcode Router}. This allows the handler to deal with a Fetch API standard
 * {@linkcode Request} and return a standard {@linkcode Response}.
 */
export declare function route<R extends string, P extends RouteParams<R>, S extends State>(middleware: ServeRouterMiddleware<R, P, S>): RouterMiddleware<R, P, S>;
export {};
