import * as dntShim from "./_dnt.shims.js";
import { type Application, type State } from "./application.js";
export interface Listener {
    addr: {
        hostname: string;
        port: number;
    };
}
export interface OakServer<T> extends AsyncIterable<T> {
    close(): void | Promise<void>;
    listen(): Listener | Promise<Listener>;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
}
export interface ServerRequest {
    readonly headers: dntShim.Headers;
    readonly method: string;
    readonly rawUrl?: string;
    readonly remoteAddr: string | undefined;
    readonly request?: dntShim.Request;
    readonly url: string;
    error(reason?: any): void;
    getBody(): ReadableStream<Uint8Array> | null;
    respond(response: dntShim.Response): void | Promise<void>;
    upgrade?(options?: UpgradeWebSocketOptions): WebSocket;
}
/** The abstract constructor interface that custom servers need to adhere to
 * when using with an {@linkcode Application}. */
export interface ServerConstructor<T extends ServerRequest> {
    new <AS extends State = Record<string, any>>(app: Application<AS>, options: Omit<ServeOptions | ServeTlsOptions, "signal">): OakServer<T>;
    prototype: OakServer<T>;
    type?: "native" | "node" | "bun";
}
export type Data = string | number[] | ArrayBuffer | Uint8Array;
export type Key = string | number[] | ArrayBuffer | Uint8Array;
export interface UpgradeWebSocketOptions {
    protocol?: string;
}
export type UpgradeWebSocketFn = (request: dntShim.Request, options?: UpgradeWebSocketOptions) => WebSocketUpgrade;
interface WebSocketUpgrade {
    response: dntShim.Response;
    socket: WebSocket;
}
export interface NetAddr {
    transport: "tcp" | "udp";
    hostname: string;
    port: number;
}
export interface ServeHandlerInfo {
    remoteAddr: dntShim.Deno.NetAddr;
}
export type ServeHandler = (request: dntShim.Request, info: ServeHandlerInfo) => dntShim.Response | Promise<dntShim.Response>;
export interface ServeOptions {
    port?: number;
    hostname?: string;
    signal?: AbortSignal;
    reusePort?: boolean;
    onError?: (error: unknown) => dntShim.Response | Promise<dntShim.Response>;
    onListen?: (params: {
        hostname: string;
        port: number;
    }) => void;
}
export interface ServeTlsOptions extends ServeOptions {
    cert: string;
    key: string;
}
export interface ServeInit {
    handler: ServeHandler;
}
export interface HttpServer extends AsyncDisposable {
    finished: Promise<void>;
    ref(): void;
    unref(): void;
    shutdown(): Promise<void>;
}
export {};
