/// <reference types="node" />
import * as dntShim from "./_dnt.shims.js";
import type { ServerRequest } from "./types.js";
type JsonReviver = (key: string, value: unknown) => unknown;
export type BodyType = "binary" | "form" | "form-data" | "json" | "text" | "unknown";
/** An object which encapsulates information around a request body. */
export declare class Body {
    #private;
    constructor(serverRequest: Pick<ServerRequest, "request" | "headers" | "getBody">, reviver?: JsonReviver);
    /** Is `true` if the request might have a body, otherwise `false`.
     *
     * **WARNING** this is an unreliable API. In HTTP/2 in many situations you
     * cannot determine if a request has a body or not unless you attempt to read
     * the body, due to the streaming nature of HTTP/2. As of Deno 1.16.1, for
     * HTTP/1.1, Deno also reflects that behavior.  The only reliable way to
     * determine if a request has a body or not is to attempt to read the body.
     */
    get has(): boolean;
    /** Exposes the "raw" `ReadableStream` of the body. */
    get stream(): ReadableStream<Uint8Array> | null;
    /** Returns `true` if the body has been consumed yet, otherwise `false`. */
    get used(): boolean;
    /** Reads a body to the end and resolves with the value as an
     * {@linkcode ArrayBuffer} */
    arrayBuffer(): Promise<ArrayBuffer>;
    /** Reads a body to the end and resolves with the value as a
     * {@linkcode Blob}. */
    blob(): Promise<dntShim.Blob>;
    /** Reads a body as a URL encoded form, resolving the value as
     * {@linkcode URLSearchParams}. */
    form(): Promise<URLSearchParams>;
    /** Reads a body to the end attempting to parse the body as a set of
     * {@linkcode FormData}. */
    formData(): Promise<dntShim.FormData>;
    /** Reads a body to the end attempting to parse the body as a JSON value.
     *
     * If a JSON reviver has been assigned, it will be used to parse the body.
     */
    json(): Promise<any>;
    /** Reads the body to the end resolving with a string. */
    text(): Promise<string>;
    /** Attempts to determine what type of the body is to help determine how best
     * to attempt to decode the body. This performs analysis on the supplied
     * `Content-Type` header of the request.
     *
     * **Note** these are not authoritative and should only be used as guidance.
     *
     * There is the ability to provide custom types when attempting to discern
     * the type. Custom types are provided in the format of an object where the
     * key is on of {@linkcode BodyType} and the value is an array of media types
     * to attempt to match. Values supplied will be additive to known media types.
     *
     * The returned value is one of the following:
     *
     * - `"binary"` - The body appears to be binary data and should be consumed as
     *   an array buffer, readable stream or blob.
     * - `"form"` - The value appears to be an URL encoded form and should be
     *   consumed as a form (`URLSearchParams`).
     * - `"form-data"` - The value appears to be multipart form data and should be
     *   consumed as form data.
     * - `"json"` - The value appears to be JSON data and should be consumed as
     *   decoded JSON.
     * - `"text"` - The value appears to be text data and should be consumed as
     *   text.
     * - `"unknown"` - Either there is no body or the body type could not be
     *   determined.
     */
    type(customMediaTypes?: Partial<Record<BodyType, string[]>>): BodyType;
}
export {};
