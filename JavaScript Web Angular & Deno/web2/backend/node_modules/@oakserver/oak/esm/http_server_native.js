// Copyright 2018-2024 the oak authors. All rights reserved. MIT license.
/** The abstraction that oak uses when dealing with requests and responses
 * within the Deno runtime.
 *
 * @module
 */
import * as dntShim from "./_dnt.shims.js";
import { NativeRequest } from "./http_server_native_request.js";
import { createPromiseWithResolvers } from "./util.js";
const serve = "Deno" in dntShim.dntGlobalThis && "serve" in dntShim.dntGlobalThis.Deno
    ? dntShim.dntGlobalThis.Deno.serve.bind(dntShim.dntGlobalThis.Deno)
    : undefined;
/** The oak abstraction of the Deno native HTTP server which is used internally
 * for handling native HTTP requests. Generally users of oak do not need to
 * worry about this class. */
// deno-lint-ignore no-explicit-any
export class Server {
    #app;
    #closed = false;
    #httpServer;
    #options;
    #stream;
    constructor(app, options) {
        if (!serve) {
            throw new Error("The native bindings for serving HTTP are not available.");
        }
        this.#app = app;
        this.#options = options;
    }
    get app() {
        return this.#app;
    }
    get closed() {
        return this.#closed;
    }
    async close() {
        if (this.#closed) {
            return;
        }
        if (this.#httpServer) {
            this.#httpServer.unref();
            await this.#httpServer.shutdown();
            this.#httpServer = undefined;
        }
        this.#closed = true;
    }
    listen() {
        if (this.#httpServer) {
            throw new Error("Server already listening.");
        }
        const { signal } = this.#options;
        const { onListen, ...options } = this.#options;
        const { promise, resolve } = createPromiseWithResolvers();
        this.#stream = new ReadableStream({
            start: (controller) => {
                this.#httpServer = serve?.({
                    handler: (req, info) => {
                        const nativeRequest = new NativeRequest(req, info);
                        controller.enqueue(nativeRequest);
                        return nativeRequest.response;
                    },
                    onListen({ hostname, port }) {
                        if (onListen) {
                            onListen({ hostname, port });
                        }
                        resolve({ addr: { hostname, port } });
                    },
                    signal,
                    ...options,
                });
            },
        });
        signal?.addEventListener("abort", () => this.close(), { once: true });
        return promise;
    }
    [Symbol.asyncIterator]() {
        if (!this.#stream) {
            throw new TypeError("Server hasn't started listening.");
        }
        return this.#stream[Symbol.asyncIterator]();
    }
    static type = "native";
}
