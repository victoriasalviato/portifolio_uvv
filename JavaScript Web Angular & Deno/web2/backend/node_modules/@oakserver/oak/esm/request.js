import { Body } from "./body.js";
import { ServerSentEventStreamTarget } from "./deps.js";
import { accepts, acceptsEncodings, acceptsLanguages, UserAgent, } from "./deps.js";
/** An interface which provides information about the current request. The
 * instance related to the current request is available on the
 * {@linkcode Context}'s `.request` property.
 *
 * The interface contains several properties to get information about the
 * request as well as several methods, which include content negotiation and
 * the ability to decode a request body.
 */
export class Request {
    #body;
    #proxy;
    #secure;
    #serverRequest;
    #url;
    #userAgent;
    #getRemoteAddr() {
        return this.#serverRequest.remoteAddr ?? "";
    }
    /** An interface to access the body of the request. This provides an API that
     * aligned to the **Fetch Request** API, but in a dedicated API.
     */
    get body() {
        return this.#body;
    }
    /** Is `true` if the request might have a body, otherwise `false`.
     *
     * **WARNING** this is an unreliable API. In HTTP/2 in many situations you
     * cannot determine if a request has a body or not unless you attempt to read
     * the body, due to the streaming nature of HTTP/2. As of Deno 1.16.1, for
     * HTTP/1.1, Deno also reflects that behaviour.  The only reliable way to
     * determine if a request has a body or not is to attempt to read the body.
     */
    get hasBody() {
        return this.#body.has;
    }
    /** The `Headers` supplied in the request. */
    get headers() {
        return this.#serverRequest.headers;
    }
    /** Request remote address. When the application's `.proxy` is true, the
     * `X-Forwarded-For` will be used to determine the requesting remote address.
     */
    get ip() {
        return (this.#proxy ? this.ips[0] : this.#getRemoteAddr()) ?? "";
    }
    /** When the application's `.proxy` is `true`, this will be set to an array of
     * IPs, ordered from upstream to downstream, based on the value of the header
     * `X-Forwarded-For`.  When `false` an empty array is returned. */
    get ips() {
        return this.#proxy
            ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                this.#getRemoteAddr()).split(/\s*,\s*/)
            : [];
    }
    /** The HTTP Method used by the request. */
    get method() {
        return this.#serverRequest.method;
    }
    /** Shortcut to `request.url.protocol === "https:"`. */
    get secure() {
        return this.#secure;
    }
    /** Set to the value of the low level oak server request abstraction.
     *
     * @deprecated this will be removed in future versions of oak. Accessing this
     * abstraction is not useful to end users and is now a bit of a misnomer.
     */
    get originalRequest() {
        return this.#serverRequest;
    }
    /** Returns the original Fetch API `Request` if available.
     *
     * This should be set with requests on Deno, but will not be set when running
     * on Node.js.
     */
    get source() {
        return this.#serverRequest.request;
    }
    /** A parsed URL for the request which complies with the browser standards.
     * When the application's `.proxy` is `true`, this value will be based off of
     * the `X-Forwarded-Proto` and `X-Forwarded-Host` header values if present in
     * the request. */
    get url() {
        if (!this.#url) {
            const serverRequest = this.#serverRequest;
            if (!this.#proxy) {
                // between 1.9.0 and 1.9.1 the request.url of the native HTTP started
                // returning the full URL, where previously it only returned the path
                // so we will try to use that URL here, but default back to old logic
                // if the URL isn't valid.
                try {
                    if (serverRequest.rawUrl) {
                        this.#url = new URL(serverRequest.rawUrl);
                        return this.#url;
                    }
                }
                catch {
                    // we don't care about errors here
                }
            }
            let proto;
            let host;
            if (this.#proxy) {
                proto = serverRequest
                    .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                    "http";
                host = serverRequest.headers.get("x-forwarded-host") ??
                    serverRequest.headers.get("host") ?? "";
            }
            else {
                proto = this.#secure ? "https" : "http";
                host = serverRequest.headers.get("host") ?? "";
            }
            try {
                this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
            }
            catch {
                throw new TypeError(`The server request URL of "${proto}://${host}${serverRequest.url}" is invalid.`);
            }
        }
        return this.#url;
    }
    /** An object representing the requesting user agent. If the `User-Agent`
     * header isn't defined in the request, all the properties will be undefined.
     *
     * See [std/http/user_agent#UserAgent](https://deno.land/std@0.217.0/http/user_agent.ts?s=UserAgent)
     * for more information.
     */
    get userAgent() {
        return this.#userAgent;
    }
    constructor(serverRequest, { proxy = false, secure = false, jsonBodyReviver } = {}) {
        this.#proxy = proxy;
        this.#secure = secure;
        this.#serverRequest = serverRequest;
        this.#body = new Body(serverRequest, jsonBodyReviver);
        this.#userAgent = new UserAgent(serverRequest.headers.get("user-agent"));
    }
    accepts(...types) {
        if (!this.#serverRequest.headers.has("Accept")) {
            return types.length ? types[0] : ["*/*"];
        }
        if (types.length) {
            return accepts(this.#serverRequest, ...types);
        }
        return accepts(this.#serverRequest);
    }
    acceptsEncodings(...encodings) {
        if (!this.#serverRequest.headers.has("Accept-Encoding")) {
            return encodings.length ? encodings[0] : ["*"];
        }
        if (encodings.length) {
            return acceptsEncodings(this.#serverRequest, ...encodings);
        }
        return acceptsEncodings(this.#serverRequest);
    }
    acceptsLanguages(...langs) {
        if (!this.#serverRequest.headers.get("Accept-Language")) {
            return langs.length ? langs[0] : ["*"];
        }
        if (langs.length) {
            return acceptsLanguages(this.#serverRequest, ...langs);
        }
        return acceptsLanguages(this.#serverRequest);
    }
    /** Take the current request and initiate server sent event connection.
     *
     * > ![WARNING]
     * > This is not intended for direct use, as it will not manage the target in
     * > the overall context or ensure that additional middleware does not attempt
     * > to respond to the request.
     */
    async sendEvents(options, init) {
        const sse = new ServerSentEventStreamTarget(options);
        await this.#serverRequest.respond(sse.asResponse(init));
        return sse;
    }
    /** Take the current request and upgrade it to a web socket, returning a web
     * standard `WebSocket` object.
     *
     * If the underlying server abstraction does not support upgrades, this will
     * throw.
     *
     * > ![WARNING]
     * > This is not intended for direct use, as it will not manage the websocket
     * > in the overall context or ensure that additional middleware does not
     * > attempt to respond to the request.
     */
    upgrade(options) {
        if (!this.#serverRequest.upgrade) {
            throw new TypeError("Web sockets upgrade not supported in this runtime.");
        }
        return this.#serverRequest.upgrade(options);
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { body, hasBody, headers, ip, ips, method, secure, url, userAgent } = this;
        return `${this.constructor.name} ${inspect({
            body,
            hasBody,
            headers,
            ip,
            ips,
            method,
            secure,
            url: url.toString(),
            userAgent,
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { body, hasBody, headers, ip, ips, method, secure, url, userAgent } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ body, hasBody, headers, ip, ips, method, secure, url, userAgent }, newOptions)}`;
    }
}
